#use-added-syntax(jitx)
defpackage etools/jitx/Network :
  import core
  import collections
  import jitx
  import jitx/commands


; The concept of this code is to provide a means for defining a lumped
; circuit network tree. The idea is to provide a "DSL" for defining
; components that are used together to form a circuit network.
;
; In this graph there are Elements and Nodes.
;  Elements are the edges of the graph and are the resistors, capacitors, etc.
;  Nodes are the pins, ground, nets, etc of the circuit

; We can think of the circuit network as a graph. We have the following
;  operations to this graph for 2-pin elements
;
;  1.  Series (+) - string multiple elements in series
;  2.  Parallel (|) - put multiple elements in parallel
;  3.  Shunt - Connect a given node to a particular net through an element
;         (For example, shunt to ground). Could also describe a pullup if needed.
;  5.  Invert (~) - Instead of connecting 1 -> 2 , connect 2 -> 1. reverses the
;        orientation of the component. Useful for polarizing caps, diodes, etc.

public defenum NetOp:
  COMPONENT
  SERIES
  PARALLEL
  SHUNT
  INVERT

; ANT = Abstract Network Tree
;   ANT are the elements of the tree that might look something like this:
;
;  Three Resistors in series
;  SERIES([ELEM(R1), ELEM(R2), ELEM(R3)])
;
;  One resistor in series with two resistors in parallel.
;  SERIES([ELEM(R1), PARALLEL([ELEM(R2), ELEM(R3)])])

public deftype ANT
public defmulti get-op (a:ANT) -> NetOp
public defmulti get-elements (a:ANT) -> Tuple<ANT>

public deftype Component <: ANT
public defmulti get-value (c:Component) -> Instantiable

public defn Component (i:Instantiable) -> Component:
  val comp = i
  new Component:
    defmethod get-op (this) : COMPONENT
    defmethod get-elements (this) : []
    defmethod get-value (this) : comp
    defmethod print (o:OutputStream, this):
      print(o, "Comp(%~)" % [name(comp)])

public defn Comp (i:Instantiable) -> Component:
  Component(i)

public deftype ANTVector <: ANT & Lengthable
public defmulti add (v:ANTVector, elem:ANT) -> False
public defmulti add-all (v:ANTVector, elems:Seqable<ANT>) -> False
defmulti children (v:ANTVector) -> Vector<ANT>

public defmethod add (v:ANTVector, elem:ANT) -> False :
  val kids = children(v)
  add(kids, elem)

public defmethod add-all (v:ANTVector, elems:Seqable<ANT>) -> False :
  val kids = children(v)
  add-all(kids, elems)

public defmethod length (v:ANTVector) -> Int :
  length(children(v))


public deftype Series <: ANTVector

public defn Series (elems:Tuple<ANT>) -> Series:
  var kids = Vector<ANT>(length(elems))
  add-all(kids, elems)

  new Series:
    defmethod get-op (this) : SERIES
    defmethod get-elements (this) : to-tuple(kids)
    defmethod children (this) : kids
    defmethod print (o:OutputStream, this) :
      print(o, "Series(%,)" % [kids])

public defn Series () -> Series:
  Series([])

public deftype Parallel <: ANTVector

public defn Parallel (elems:Tuple<ANT>) -> Parallel:
  var kids = Vector<ANT>(length(elems))
  add-all(kids, elems)

  new Parallel:
    defmethod get-op (this) : PARALLEL
    defmethod get-elements (this) : to-tuple(kids)
    defmethod children (this) : kids
    defmethod print (o:OutputStream, this) :
      print(o, "Parallel(%,)" % [kids])

public defn Parallel () -> Parallel :
  Parallel([])

public deftype Shunt <: ANT
public defmulti get-net (s:Shunt) -> JITXObject

public defn Shunt (n:JITXObject, a:ANT) -> Shunt :
  val elem = a
  val _net = n

  new Shunt :
    defmethod get-op (this) : SHUNT
    defmethod get-elements (this) : [elem]
    defmethod get-net (this) : _net
    defmethod print (o:OutputStream, this) :
      print(o, "Shunt(%~, net=%~)" % [a, n])

public deftype Invert <: ANT

public defn Invert (a:ANT) -> Invert :
  val elem = a
  new Invert :
    defmethod get-op (this) : INVERT
    defmethod get-elements (this) : [elem]
    defmethod print (o:OutputStream, this) :
      print(o, "Invert: %~" % [a])

public defn get-pin-by-name (obj:JITXObject, name:String) -> Maybe<JITXObject> :
  label<Maybe<JITXObject>> return:
    val pat = to-string(".%_" % [name])
    for p in pins(obj) do:
      val refName = to-string("%_" % [ref(p)])
      if suffix?(refName, pat) :
        return(One(p))
    return(None())

public defn get-cathode-anode (obj:JITXObject) -> Maybe<[JITXObject, JITXObject]> :
  val mC = get-pin-by-name(obj, "c")
  val mA = get-pin-by-name(obj, "a")
  match(mC, mA) :
    (oC:One<JITXObject>, oA:One<JITXObject>): One([value(oC), value(oA)])
    (x,y): None()

public defn get-pins (obj:JITXObject) -> [JITXObject, JITXObject] :
  ; Given an instantiated object - find the pins that
  ;  define its interfaces.
  ;  For caps/resistors, this is usually a tuple `p` of two pins
  ;  For Diodes, this is usually c / a

  val mCA = get-cathode-anode(obj)
  match(mCA):
    (oCA:One<[JITXObject, JITXObject]>):
      val ret = value(oCA)
      ret
    (_:None):
      [obj.p[1], obj.p[2]]

public defn extrapolate-all (a:ANTVector) -> Seq<[JITXObject, JITXObject]> :
  inside pcb-module:
    for elem in get-elements(a) seq:
      extrapolate(elem)

public defn connect-series (a:Series) -> [JITXObject, JITXObject] :
  inside pcb-module:
    val pinSets = to-tuple(extrapolate-all(a))
    val cnt = length(pinSets)

    ; Series connect all of the components
    for i in 0 to (cnt - 1) do :
      net (pinSets[i][1], pinSets[i + 1][0])

    ; Return the first pin and the last pin
    [pinSets[0][0], pinSets[cnt - 1][1]]

public defn connect-parallel (a:Parallel) -> [JITXObject, JITXObject] :
  inside pcb-module:
    val pinSets = to-tuple(extrapolate-all(a))
    val cnt = length(pinSets)

    ; @TODO - for `shunt` to really do anything - I think I need to
    ;    check if any of the pins are already connected.
    ;    If one of the pins is already connected - then we should
    ;    filter it out from this set.
    val p1Set = map(get{_, 0}, pinSets)
    val p2Set = map(get{_, 1}, pinSets)
    net (p1Set)
    net (p2Set)

    [p1Set[0], p2Set[0]]

public defn extrapolate (a:ANT) -> [JITXObject, JITXObject] :
  inside pcb-module :
    match(a) :
      (s:Series):
        ; println("Extrapolate Series: %~" % [s])
        connect-series(s)
      (s:Parallel):
        ;println("Extrapolate Parallel: %~" % [s])
        connect-parallel(s)
      (s:Component):
        ;println("Extrapolate Component: %~" % [s])
        inst obj : get-value(s)
        get-pins(obj)
      (s:Shunt):
        ;println("Extrapolate Shunt: %~" % [s])
        val child = get-elements(s)[0]
        val [p1, p2] = extrapolate(child)
        val n = get-net(s)
        ;println("Net: %~" % [n])
        net (p2, n)
        [p1, p2]
      (s:Invert):
        ;println("Extrapolate Invert: %~" % [s])
        val child = get-elements(s)[0]
        val [p1, p2] = extrapolate(child)
        [p2, p1]

public defn make-circuit (a:ANT) -> Instantiable :

  pcb-module network-circuit:
    ; pin p[[1 2]]
    port p : pin[[1 2]]
    val [p1, p2] = extrapolate(a)
    net (p[1], p1)
    net (p[2], p2)

  network-circuit


;;;;;;;;;;;;;;;;;;
; Operators
;;;;;;;;;;;;;;;;;;

public defn bit-not (a:ANT) -> ANT:
  Invert(a)

public defn bit-not (a:Instantiable) -> ANT:
  Invert(Comp(a))

; @TODO - for Series and Parallel, I kind of figure
;   there will be multiple plusses in a row like this:
;  R1 + R2 + (R3|R4|Rg|Rf)
;
;  It would be nice if there was some pass that collapses
;  the Parallel(R3, Parallel(R4, Parallel(Rg, Rf))) into
;      Parallel(R3, R4, Rg, Rf)

public defn plus (a:ANT, b:ANT) -> ANT:
  Series([a,b])

public defn plus (a:ANT, b:Instantiable) -> ANT :
  Series([a, Comp(b)])

public defn plus (a:Instantiable, b:ANT) -> ANT :
  Series([Comp(a), b])

public defn bit-or (a:ANT, b:ANT) -> ANT:
  Parallel([a,b])

public defn bit-or (a:ANT, b:Instantiable) -> ANT :
  Parallel([a, Comp(b)])

public defn bit-or (a:Instantiable, b:ANT) -> ANT :
  Parallel([Comp(a), b])

public defn shift-right (a:ANT, n:JITXObject) -> ANT :
  Shunt(n, a)